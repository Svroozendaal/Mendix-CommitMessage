using System.Text.Json;

namespace AutoCommitMessage;

/// <summary>
/// Computes resource-level Mendix model differences from two JSON dumps generated by <c>mx dump-mpr</c>.
/// </summary>
public static class MendixModelDiffService
{
    private static readonly string[] NameFields = { "$QualifiedName", "name", "$ID" };
    private static readonly HashSet<string> TrackableContainerProperties = new(StringComparer.OrdinalIgnoreCase)
    {
        "documents",
        "projectDocuments",
    };

    private static readonly HashSet<string> TrackableDomainModelTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "DomainModels$Entity",
        "DomainModels$Association",
        "DomainModels$Enumeration",
    };

    private static readonly Dictionary<string, string> ElementTypeOverrides = new(StringComparer.OrdinalIgnoreCase)
    {
        ["DomainModels$Entity"] = "Entity",
        ["DomainModels$Association"] = "Association",
        ["DomainModels$Enumeration"] = "Enumeration",
        ["Pages$Page"] = "Page",
        ["Pages$Snippet"] = "Snippet",
        ["Microflows$Microflow"] = "Microflow",
        ["Nanoflows$Nanoflow"] = "Nanoflow",
    };

    private static readonly HashSet<string> IgnoredDetailFields = new(StringComparer.Ordinal)
    {
        "$ID",
        "$Type",
        "$ContainerID",
        "$ContainerProperty",
        "$QualifiedName",
    };

    private const string MicroflowModelType = "Microflows$Microflow";
    private const string ActionActivityModelType = "Microflows$ActionActivity";
    private const string DomainEntityModelType = "DomainModels$Entity";
    private const string DomainAttributeModelType = "DomainModels$Attribute";

    /// <summary>
    /// Compares two model dump JSON files and returns detected resource-level changes.
    /// </summary>
    /// <param name="workingJson">Path to the working-copy dump JSON.</param>
    /// <param name="headJson">Path to the HEAD dump JSON.</param>
    /// <returns>Collection of model changes.</returns>
    public static List<MendixModelChange> CompareDumps(string workingJson, string headJson)
    {
        using var workingDocument = ParseDump(workingJson);
        using var headDocument = ParseDump(headJson);

        var workingSnapshot = BuildSnapshot(workingDocument.RootElement);
        var headSnapshot = BuildSnapshot(headDocument.RootElement);
        var changeMap = new Dictionary<string, MutableResourceChange>(StringComparer.OrdinalIgnoreCase);

        foreach (var (resourceId, resource) in workingSnapshot.ResourcesById)
        {
            if (!headSnapshot.ResourcesById.ContainsKey(resourceId))
            {
                changeMap[resourceId] = new MutableResourceChange("Added", resource);
            }
        }

        foreach (var (resourceId, resource) in headSnapshot.ResourcesById)
        {
            if (!workingSnapshot.ResourcesById.ContainsKey(resourceId))
            {
                changeMap[resourceId] = new MutableResourceChange("Deleted", resource);
            }
        }

        foreach (var (resourceId, workingResource) in workingSnapshot.ResourcesById)
        {
            if (!headSnapshot.ResourcesById.TryGetValue(resourceId, out var headResource))
            {
                continue;
            }

            if (ElementsEqual(workingResource.Object, headResource.Object))
            {
                continue;
            }

            var modified = EnsureModifiedChange(changeMap, resourceId, workingResource);
            modified.DirectDetails = MergeDetailTexts(
                modified.DirectDetails,
                BuildModificationDetails(headResource.Object, workingResource.Object));
        }

        AddNestedOwnershipChanges(
            changeMap,
            workingSnapshot,
            headSnapshot,
            workingSnapshot.ObjectsById.Keys.Except(headSnapshot.ObjectsById.Keys, StringComparer.OrdinalIgnoreCase),
            "Added",
            useWorkingSnapshot: true);

        AddNestedOwnershipChanges(
            changeMap,
            workingSnapshot,
            headSnapshot,
            headSnapshot.ObjectsById.Keys.Except(workingSnapshot.ObjectsById.Keys, StringComparer.OrdinalIgnoreCase),
            "Deleted",
            useWorkingSnapshot: false);

        var modifiedObjectIds = workingSnapshot.ObjectsById.Keys
            .Intersect(headSnapshot.ObjectsById.Keys, StringComparer.OrdinalIgnoreCase)
            .Where(objectId => !ElementsEqual(workingSnapshot.ObjectsById[objectId], headSnapshot.ObjectsById[objectId]));

        AddNestedOwnershipChanges(
            changeMap,
            workingSnapshot,
            headSnapshot,
            modifiedObjectIds,
            "Modified",
            useWorkingSnapshot: true);

        AddResourceSpecificDetails(changeMap, workingSnapshot, headSnapshot);

        return changeMap.Values
            .Select(ToModelChange)
            .OrderBy(change => change.ElementType, StringComparer.OrdinalIgnoreCase)
            .ThenBy(change => change.ElementName, StringComparer.OrdinalIgnoreCase)
            .ThenBy(change => change.ChangeType, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private static void AddNestedOwnershipChanges(
        Dictionary<string, MutableResourceChange> changeMap,
        DumpSnapshot workingSnapshot,
        DumpSnapshot headSnapshot,
        IEnumerable<string> changedObjectIds,
        string nestedChangeType,
        bool useWorkingSnapshot)
    {
        var ownerSnapshot = useWorkingSnapshot ? workingSnapshot : headSnapshot;

        foreach (var objectId in changedObjectIds)
        {
            if (ownerSnapshot.ResourcesById.ContainsKey(objectId))
            {
                continue;
            }

            var ownerResourceId = ResolveOwningResourceId(ownerSnapshot, objectId);
            if (string.IsNullOrWhiteSpace(ownerResourceId))
            {
                continue;
            }

            var ownerDescriptor = ResolveOwnerDescriptor(ownerResourceId, workingSnapshot, headSnapshot);
            if (ownerDescriptor is null)
            {
                continue;
            }

            if (changeMap.TryGetValue(ownerResourceId, out var existingHardChange) &&
                existingHardChange.ChangeType is "Added" or "Deleted")
            {
                continue;
            }

            var modified = EnsureModifiedChange(changeMap, ownerResourceId, ownerDescriptor);
            modified.NestedChanges.Increment(nestedChangeType);
        }
    }

    private static MutableResourceChange EnsureModifiedChange(
        Dictionary<string, MutableResourceChange> changeMap,
        string resourceId,
        ResourceDescriptor descriptor)
    {
        if (changeMap.TryGetValue(resourceId, out var existing))
        {
            if (existing.ChangeType is "Added" or "Deleted")
            {
                return existing;
            }

            existing.ChangeType = "Modified";
            existing.Descriptor = descriptor;
            return existing;
        }

        var created = new MutableResourceChange("Modified", descriptor);
        changeMap[resourceId] = created;
        return created;
    }

    private static MendixModelChange ToModelChange(MutableResourceChange change)
    {
        var details = MergeDetailTexts(change.DirectDetails, change.NestedChanges.ToDetailText());
        return new MendixModelChange(
            change.ChangeType,
            change.Descriptor.ElementType,
            change.Descriptor.ElementName,
            details);
    }

    private static void AddResourceSpecificDetails(
        Dictionary<string, MutableResourceChange> changeMap,
        DumpSnapshot workingSnapshot,
        DumpSnapshot headSnapshot)
    {
        foreach (var (resourceId, resourceChange) in changeMap)
        {
            workingSnapshot.ResourcesById.TryGetValue(resourceId, out var workingDescriptor);
            headSnapshot.ResourcesById.TryGetValue(resourceId, out var headDescriptor);

            var resourceSpecificDetails = BuildResourceSpecificDetails(
                resourceChange.ChangeType,
                workingDescriptor,
                headDescriptor);

            resourceChange.DirectDetails = MergeDetailTexts(resourceChange.DirectDetails, resourceSpecificDetails);
        }
    }

    private static string? BuildResourceSpecificDetails(
        string changeType,
        ResourceDescriptor? workingDescriptor,
        ResourceDescriptor? headDescriptor)
    {
        var reference = workingDescriptor ?? headDescriptor;
        if (reference is null)
        {
            return null;
        }

        if (string.Equals(reference.ModelType, MicroflowModelType, StringComparison.OrdinalIgnoreCase))
        {
            return BuildMicroflowActionDetails(changeType, workingDescriptor?.Object, headDescriptor?.Object);
        }

        if (string.Equals(reference.ModelType, DomainEntityModelType, StringComparison.OrdinalIgnoreCase))
        {
            return BuildDomainEntityAttributeDetails(changeType, workingDescriptor?.Object, headDescriptor?.Object);
        }

        return null;
    }

    private static string? BuildMicroflowActionDetails(
        string changeType,
        JsonElement? workingResource,
        JsonElement? headResource)
    {
        var source = string.Equals(changeType, "Deleted", StringComparison.OrdinalIgnoreCase)
            ? headResource
            : (workingResource ?? headResource);

        if (source is null)
        {
            return null;
        }

        var actionSummary = CollectMicroflowActionSummary(source.Value);
        if (actionSummary.ActionCounts.Count == 0)
        {
            return null;
        }

        var total = actionSummary.ActionCounts.Values.Sum();
        var actionCounterSummary = FormatCounterList(actionSummary.ActionCounts);
        var actionDetailSummary = FormatActionDetailList(actionSummary.ActionDescriptors, actionSummary.ActionCounts);
        return string.IsNullOrWhiteSpace(actionDetailSummary)
            ? $"actions used ({total}): {actionCounterSummary}"
            : $"actions used ({total}): {actionCounterSummary}; action details: {actionDetailSummary}";
    }

    private static MicroflowActionSummary CollectMicroflowActionSummary(JsonElement microflowObject)
    {
        var actionCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        var actionDescriptors = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);
        var stack = new Stack<JsonElement>();
        stack.Push(microflowObject);

        while (stack.Count > 0)
        {
            var current = stack.Pop();

            switch (current.ValueKind)
            {
                case JsonValueKind.Object:
                {
                    var modelType = TryReadStringProperty(current, "$Type");
                    if (string.Equals(modelType, ActionActivityModelType, StringComparison.OrdinalIgnoreCase) &&
                        TryReadProperty(current, "action", out var actionElement) &&
                        actionElement.ValueKind == JsonValueKind.Object)
                    {
                        var actionType = TryReadStringProperty(actionElement, "$Type");
                        if (!string.IsNullOrWhiteSpace(actionType))
                        {
                            var actionName = ShortTypeName(actionType);
                            IncrementCount(actionCounts, actionName);
                            var descriptor = BuildActionDescriptor(actionName, actionElement);
                            if (!string.IsNullOrWhiteSpace(descriptor))
                            {
                                AddActionDescriptor(actionDescriptors, actionName, descriptor);
                            }
                        }
                    }

                    foreach (var property in current.EnumerateObject())
                    {
                        stack.Push(property.Value);
                    }

                    break;
                }

                case JsonValueKind.Array:
                    foreach (var item in current.EnumerateArray())
                    {
                        stack.Push(item);
                    }

                    break;
            }
        }

        return new MicroflowActionSummary(actionCounts, actionDescriptors);
    }

    private static string? BuildActionDescriptor(string actionName, JsonElement actionElement) =>
        actionName switch
        {
            "RetrieveAction" => BuildRetrieveActionDescriptor(actionElement),
            "ChangeObjectAction" => BuildChangeObjectActionDescriptor(actionElement),
            "CommitAction" => BuildCommitActionDescriptor(actionElement),
            "CreateObjectAction" => BuildCreateObjectActionDescriptor(actionElement),
            "ChangeVariableAction" => BuildChangeVariableActionDescriptor(actionElement),
            "CreateVariableAction" => BuildCreateVariableActionDescriptor(actionElement),
            "DeleteAction" => BuildDeleteActionDescriptor(actionElement),
            "MicroflowCallAction" => BuildMicroflowCallActionDescriptor(actionElement),
            "JavaActionCallAction" => BuildNamedCallActionDescriptor(actionElement, "java action", "javaAction", "actionName"),
            "JavaScriptActionCallAction" => BuildNamedCallActionDescriptor(actionElement, "javascript action", "javaScriptAction", "actionName"),
            _ => null,
        };

    private static string? BuildRetrieveActionDescriptor(JsonElement actionElement)
    {
        var outputVariableName = TryReadStringProperty(actionElement, "outputVariableName");
        var outputLabel = string.IsNullOrWhiteSpace(outputVariableName) ? "object(s)" : outputVariableName;
        var details = new List<string>();
        AppendOption(details, "retrieveType", TryReadStringProperty(actionElement, "retrieveType"));
        AppendOption(details, "overAssociations", TryReadStringProperty(actionElement, "retrieveOverAssociations"));
        AppendOption(details, "xPath", TryReadStringProperty(actionElement, "xPathConstraint"), 220);

        if (TryReadProperty(actionElement, "range", out var rangeElement) && rangeElement.ValueKind == JsonValueKind.Object)
        {
            var rangeDetails = BuildRetrieveRangeDetails(rangeElement);
            if (!string.IsNullOrWhiteSpace(rangeDetails))
            {
                details.Add($"range={rangeDetails}");
            }
        }

        if (TryReadProperty(actionElement, "sortExpression", out var sortExpressionElement) && sortExpressionElement.ValueKind == JsonValueKind.Array)
        {
            var sortDetails = BuildRetrieveSortDetails(sortExpressionElement);
            if (!string.IsNullOrWhiteSpace(sortDetails))
            {
                details.Add($"sort={sortDetails}");
            }
        }

        if (!TryReadProperty(actionElement, "retrieveSource", out var retrieveSource) ||
            retrieveSource.ValueKind != JsonValueKind.Object)
        {
            var baseDescriptor = string.IsNullOrWhiteSpace(outputVariableName)
                ? null
                : $"retrieve {outputVariableName}";

            if (string.IsNullOrWhiteSpace(baseDescriptor))
            {
                return null;
            }

            return details.Count == 0
                ? baseDescriptor
                : $"{baseDescriptor} ({string.Join(", ", details)})";
        }

        var sourceType = ShortTypeName(TryReadStringProperty(retrieveSource, "$Type") ?? string.Empty);
        string sourceDescriptor;
        if (string.Equals(sourceType, "AssociationRetrieveSource", StringComparison.OrdinalIgnoreCase))
        {
            var association = ShortMemberName(TryReadStringProperty(retrieveSource, "association")) ?? "<association>";
            var startVariable = TryReadStringProperty(retrieveSource, "startVariableName");
            var startLabel = string.IsNullOrWhiteSpace(startVariable) ? "<object>" : startVariable;
            sourceDescriptor = $"retrieve {outputLabel} over association {association} from {startLabel}";
        }
        else if (string.Equals(sourceType, "DatabaseRetrieveSource", StringComparison.OrdinalIgnoreCase))
        {
            var entity = TryReadStringProperty(retrieveSource, "entity");
            var entityLabel = string.IsNullOrWhiteSpace(entity) ? "<entity>" : entity;
            sourceDescriptor = $"retrieve {outputLabel} from {entityLabel}";
        }
        else
        {
            var sourceLabel = string.IsNullOrWhiteSpace(sourceType) ? "source" : sourceType;
            sourceDescriptor = $"retrieve {outputLabel} via {sourceLabel}";
        }

        return details.Count == 0
            ? sourceDescriptor
            : $"{sourceDescriptor} ({string.Join(", ", details)})";
    }

    private static string BuildChangeObjectActionDescriptor(JsonElement actionElement)
    {
        var variableName = TryReadStringProperty(actionElement, "changeVariableName");
        var variableLabel = string.IsNullOrWhiteSpace(variableName) ? "object" : variableName;
        var details = new List<string>();
        var memberSummary = FormatChangedMemberSummary(actionElement);
        if (!string.IsNullOrWhiteSpace(memberSummary))
        {
            details.Add(memberSummary);
        }

        AppendOption(details, "refreshInClient", TryReadStringProperty(actionElement, "refreshInClient"));
        AppendOption(details, "withEvents", TryReadStringProperty(actionElement, "withEvents"));
        return details.Count == 0 ? $"change {variableLabel}" : $"change {variableLabel} ({string.Join("; ", details)})";
    }

    private static string BuildCommitActionDescriptor(JsonElement actionElement)
    {
        var variableName = TryReadStringProperty(actionElement, "commitVariableName");
        var baseDescriptor = string.IsNullOrWhiteSpace(variableName)
            ? "commit object(s)"
            : $"commit {variableName}";

        var details = new List<string>();
        AppendOption(details, "refreshInClient", TryReadStringProperty(actionElement, "refreshInClient"));
        AppendOption(details, "withEvents", TryReadStringProperty(actionElement, "withEvents"));
        return details.Count == 0 ? baseDescriptor : $"{baseDescriptor} ({string.Join(", ", details)})";
    }

    private static string BuildCreateObjectActionDescriptor(JsonElement actionElement)
    {
        var entityName = TryReadStringProperty(actionElement, "entity");
        var outputVariableName = TryReadStringProperty(actionElement, "outputVariableName");
        var entityLabel = string.IsNullOrWhiteSpace(entityName) ? "object" : entityName;

        var baseDescriptor = string.IsNullOrWhiteSpace(outputVariableName)
            ? $"create {entityLabel}"
            : $"create {entityLabel} as {outputVariableName}";

        var details = new List<string>();
        var memberSummary = FormatChangedMemberSummary(actionElement);
        if (!string.IsNullOrWhiteSpace(memberSummary))
        {
            details.Add(memberSummary);
        }

        return details.Count == 0 ? baseDescriptor : $"{baseDescriptor} ({string.Join("; ", details)})";
    }

    private static string? BuildChangeVariableActionDescriptor(JsonElement actionElement)
    {
        var variableName = TryReadAnyStringProperty(actionElement, "changeVariableName", "variableName");
        if (string.IsNullOrWhiteSpace(variableName))
        {
            return null;
        }

        var expression = TryReadActionExpression(actionElement, "value", "newValue", "expression");
        return string.IsNullOrWhiteSpace(expression)
            ? $"change variable {variableName}"
            : $"change variable {variableName}={expression}";
    }

    private static string? BuildCreateVariableActionDescriptor(JsonElement actionElement)
    {
        var variableName = TryReadAnyStringProperty(actionElement, "outputVariableName", "variableName");
        if (string.IsNullOrWhiteSpace(variableName))
        {
            return null;
        }

        var variableType = TryReadAnyStringProperty(actionElement, "variableType", "type");
        var expression = TryReadActionExpression(actionElement, "value", "initialValue", "initialValueExpression", "defaultValue");
        var baseDescriptor = string.IsNullOrWhiteSpace(variableType)
            ? $"create variable {variableName}"
            : $"create variable {variableName}:{variableType}";

        return string.IsNullOrWhiteSpace(expression)
            ? baseDescriptor
            : $"{baseDescriptor}={expression}";
    }

    private static string? BuildDeleteActionDescriptor(JsonElement actionElement)
    {
        var variableName = TryReadAnyStringProperty(actionElement, "deleteVariableName", "inputVariableName", "variableName");
        if (string.IsNullOrWhiteSpace(variableName))
        {
            return null;
        }

        var details = new List<string>();
        AppendOption(details, "refreshInClient", TryReadStringProperty(actionElement, "refreshInClient"));
        return details.Count == 0
            ? $"delete {variableName}"
            : $"delete {variableName} ({string.Join(", ", details)})";
    }

    private static string? BuildMicroflowCallActionDescriptor(JsonElement actionElement)
    {
        var microflowName = TryReadStringProperty(actionElement, "microflow");
        var outputVariableName = TryReadStringProperty(actionElement, "outputVariableName");

        if (string.IsNullOrWhiteSpace(microflowName) && string.IsNullOrWhiteSpace(outputVariableName))
        {
            return null;
        }

        var baseDescriptor = string.IsNullOrWhiteSpace(microflowName)
            ? "call microflow"
            : $"call microflow {microflowName}";

        if (!string.IsNullOrWhiteSpace(outputVariableName))
        {
            baseDescriptor = $"{baseDescriptor} -> {outputVariableName}";
        }

        return baseDescriptor;
    }

    private static string? BuildNamedCallActionDescriptor(
        JsonElement actionElement,
        string actionLabel,
        params string[] actionNamePropertyCandidates)
    {
        var actionName = TryReadAnyStringProperty(actionElement, actionNamePropertyCandidates);
        var outputVariableName = TryReadStringProperty(actionElement, "outputVariableName");
        if (string.IsNullOrWhiteSpace(actionName) && string.IsNullOrWhiteSpace(outputVariableName))
        {
            return null;
        }

        var baseDescriptor = string.IsNullOrWhiteSpace(actionName)
            ? $"call {actionLabel}"
            : $"call {actionLabel} {actionName}";

        if (!string.IsNullOrWhiteSpace(outputVariableName))
        {
            baseDescriptor = $"{baseDescriptor} -> {outputVariableName}";
        }

        return baseDescriptor;
    }

    private static string? FormatChangedMemberSummary(JsonElement actionElement, int maxMembers = 8)
    {
        if (!TryReadProperty(actionElement, "items", out var items) || items.ValueKind != JsonValueKind.Array)
        {
            return null;
        }

        var uniqueMemberAssignments = new List<string>();
        var seenMembers = new HashSet<string>(StringComparer.Ordinal);

        foreach (var item in items.EnumerateArray())
        {
            if (item.ValueKind != JsonValueKind.Object)
            {
                continue;
            }

            var attribute = ShortMemberName(TryReadStringProperty(item, "attribute"));
            var association = ShortMemberName(TryReadStringProperty(item, "association"));
            var memberName = string.IsNullOrWhiteSpace(attribute) ? association : attribute;
            memberName ??= "<member>";
            var valueExpression = TryReadPropertyAsText(item, "value", 180);
            var memberAssignment = string.IsNullOrWhiteSpace(valueExpression)
                ? memberName
                : $"{memberName}={valueExpression}";

            if (!seenMembers.Add(memberAssignment))
            {
                continue;
            }

            uniqueMemberAssignments.Add(memberAssignment);
        }

        if (uniqueMemberAssignments.Count == 0)
        {
            return null;
        }

        var visibleMembers = uniqueMemberAssignments.Take(maxMembers).ToList();
        var remaining = uniqueMemberAssignments.Count - visibleMembers.Count;
        if (remaining > 0)
        {
            visibleMembers.Add($"+{remaining} more");
        }

        return string.Join(", ", visibleMembers);
    }

    private static string? ShortMemberName(string? qualifiedName)
    {
        if (string.IsNullOrWhiteSpace(qualifiedName))
        {
            return null;
        }

        var trimmed = qualifiedName.Trim();
        var slashIndex = trimmed.LastIndexOf('/');
        if (slashIndex >= 0 && slashIndex < trimmed.Length - 1)
        {
            trimmed = trimmed[(slashIndex + 1)..];
        }

        var dotIndex = trimmed.LastIndexOf('.');
        if (dotIndex >= 0 && dotIndex < trimmed.Length - 1)
        {
            return trimmed[(dotIndex + 1)..];
        }

        return trimmed;
    }

    private static void AddActionDescriptor(
        Dictionary<string, HashSet<string>> actionDescriptors,
        string actionName,
        string descriptor)
    {
        if (!actionDescriptors.TryGetValue(actionName, out var descriptorSet))
        {
            descriptorSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            actionDescriptors[actionName] = descriptorSet;
        }

        descriptorSet.Add(descriptor.Trim());
    }

    private static string? FormatActionDetailList(
        Dictionary<string, HashSet<string>> actionDescriptors,
        Dictionary<string, int> actionCounts,
        int maxActionTypes = 12,
        int maxDescriptorsPerType = 6)
    {
        if (actionDescriptors.Count == 0)
        {
            return null;
        }

        var actionTypes = actionCounts
            .Keys
            .Where(actionDescriptors.ContainsKey)
            .OrderByDescending(actionName => actionCounts.TryGetValue(actionName, out var count) ? count : 0)
            .ThenBy(actionName => actionName, StringComparer.OrdinalIgnoreCase)
            .Take(maxActionTypes)
            .ToArray();

        if (actionTypes.Length == 0)
        {
            return null;
        }

        var details = new List<string>();
        foreach (var actionType in actionTypes)
        {
            if (!actionDescriptors.TryGetValue(actionType, out var descriptorSet) || descriptorSet.Count == 0)
            {
                continue;
            }

            var orderedDescriptors = descriptorSet
                .OrderBy(descriptor => descriptor, StringComparer.OrdinalIgnoreCase)
                .Take(maxDescriptorsPerType)
                .ToArray();

            if (orderedDescriptors.Length == 0)
            {
                continue;
            }

            var descriptorText = string.Join(" | ", orderedDescriptors);
            var remainingDescriptors = descriptorSet.Count - orderedDescriptors.Length;
            if (remainingDescriptors > 0)
            {
                descriptorText = $"{descriptorText} (+{remainingDescriptors} more)";
            }

            details.Add($"{actionType}: {descriptorText}");
        }

        var remainingActionTypes = actionDescriptors.Keys
            .Except(actionTypes, StringComparer.OrdinalIgnoreCase)
            .Count();
        if (remainingActionTypes > 0)
        {
            details.Add($"+{remainingActionTypes} more action type{(remainingActionTypes == 1 ? string.Empty : "s")}");
        }

        return details.Count == 0 ? null : string.Join("; ", details);
    }

    private static string? BuildRetrieveRangeDetails(JsonElement rangeElement)
    {
        var parts = new List<string>();
        var rangeType = ShortTypeName(TryReadStringProperty(rangeElement, "$Type") ?? string.Empty);
        if (!string.IsNullOrWhiteSpace(rangeType) && !string.Equals(rangeType, "<unknown>", StringComparison.Ordinal))
        {
            parts.Add(rangeType);
        }

        AppendOption(parts, "amount", TryReadStringProperty(rangeElement, "amount"));
        AppendOption(parts, "offset", TryReadStringProperty(rangeElement, "offset"));
        AppendOption(parts, "begin", TryReadStringProperty(rangeElement, "begin"));
        AppendOption(parts, "end", TryReadStringProperty(rangeElement, "end"));
        AppendOption(parts, "limit", TryReadStringProperty(rangeElement, "limit"));

        return parts.Count == 0 ? null : string.Join(", ", parts);
    }

    private static string? BuildRetrieveSortDetails(JsonElement sortExpressionElement, int maxSortEntries = 5)
    {
        var sortEntries = new List<string>();
        foreach (var sortExpression in sortExpressionElement.EnumerateArray())
        {
            if (sortExpression.ValueKind != JsonValueKind.Object)
            {
                continue;
            }

            var attribute = ShortMemberName(TryReadStringProperty(sortExpression, "attribute")) ?? "<attribute>";
            var sortOrder = TryReadStringProperty(sortExpression, "sortOrder");
            sortEntries.Add(string.IsNullOrWhiteSpace(sortOrder) ? attribute : $"{attribute}:{sortOrder}");
        }

        if (sortEntries.Count == 0)
        {
            return null;
        }

        var visibleEntries = sortEntries.Take(maxSortEntries).ToList();
        var remainingEntries = sortEntries.Count - visibleEntries.Count;
        if (remainingEntries > 0)
        {
            visibleEntries.Add($"+{remainingEntries} more");
        }

        return string.Join(", ", visibleEntries);
    }

    private static void AppendOption(
        ICollection<string> options,
        string key,
        string? value,
        int maxLength = 140)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return;
        }

        var normalizedValue = NormalizeInlineText(value, maxLength);
        if (normalizedValue.Length == 0)
        {
            return;
        }

        options.Add($"{key}={normalizedValue}");
    }

    private static string? TryReadAnyStringProperty(JsonElement element, params string[] propertyNameCandidates)
    {
        foreach (var propertyName in propertyNameCandidates)
        {
            var value = TryReadStringProperty(element, propertyName);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return value;
            }
        }

        return null;
    }

    private static string? TryReadActionExpression(JsonElement actionElement, params string[] propertyNameCandidates)
    {
        foreach (var propertyName in propertyNameCandidates)
        {
            var expression = TryReadPropertyAsText(actionElement, propertyName, 220);
            if (!string.IsNullOrWhiteSpace(expression))
            {
                return expression;
            }
        }

        return null;
    }

    private static string? TryReadPropertyAsText(JsonElement element, string propertyName, int maxLength)
    {
        if (!TryReadProperty(element, propertyName, out var propertyValue))
        {
            return null;
        }

        var valueText = FormatElementValueForDisplay(propertyValue, maxLength);
        return string.IsNullOrWhiteSpace(valueText) ? null : valueText;
    }

    private static string? FormatElementValueForDisplay(JsonElement element, int maxLength)
    {
        return element.ValueKind switch
        {
            JsonValueKind.String => NormalizeInlineText(element.GetString() ?? string.Empty, maxLength),
            JsonValueKind.Number => element.GetRawText(),
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Null => "null",
            JsonValueKind.Array => $"[{element.GetArrayLength()} item(s)]",
            JsonValueKind.Object => FormatObjectValueForDisplay(element, maxLength),
            _ => NormalizeInlineText(element.GetRawText(), maxLength),
        };
    }

    private static string FormatObjectValueForDisplay(JsonElement element, int maxLength)
    {
        var summaryParts = new List<string>();
        var fieldCandidates = new[]
        {
            "value",
            "variableName",
            "text",
            "entity",
            "microflow",
            "page",
            "association",
            "attribute",
        };

        foreach (var fieldName in fieldCandidates)
        {
            var fieldValue = TryReadStringProperty(element, fieldName);
            if (string.IsNullOrWhiteSpace(fieldValue))
            {
                continue;
            }

            summaryParts.Add($"{fieldName}={NormalizeInlineText(fieldValue, maxLength / 2)}");
        }

        var type = TryReadStringProperty(element, "$Type");
        var typeLabel = string.IsNullOrWhiteSpace(type) ? null : ShortTypeName(type);
        if (summaryParts.Count == 0)
        {
            return string.IsNullOrWhiteSpace(typeLabel) ? "<object>" : typeLabel;
        }

        var summaryText = string.Join(", ", summaryParts);
        if (!string.IsNullOrWhiteSpace(typeLabel))
        {
            summaryText = $"{typeLabel}({summaryText})";
        }

        return NormalizeInlineText(summaryText, maxLength);
    }

    private static string NormalizeInlineText(string text, int maxLength = 140)
    {
        if (string.IsNullOrWhiteSpace(text))
        {
            return string.Empty;
        }

        var normalized = string.Join(" ", text.Split((char[]?)null, StringSplitOptions.RemoveEmptyEntries)).Trim();
        if (normalized.Length > maxLength)
        {
            normalized = $"{normalized[..maxLength]}...";
        }

        return normalized;
    }

    private static string? BuildDomainEntityAttributeDetails(
        string changeType,
        JsonElement? workingResource,
        JsonElement? headResource)
    {
        var workingAttributes = workingResource is null
            ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
            : CollectDomainAttributes(workingResource.Value);
        var headAttributes = headResource is null
            ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
            : CollectDomainAttributes(headResource.Value);

        if (string.Equals(changeType, "Added", StringComparison.OrdinalIgnoreCase))
        {
            if (workingAttributes.Count == 0)
            {
                return null;
            }

            var allNames = workingAttributes.Values.OrderBy(name => name, StringComparer.OrdinalIgnoreCase);
            return $"attributes added ({workingAttributes.Count}): {FormatNameList(allNames)}";
        }

        if (string.Equals(changeType, "Deleted", StringComparison.OrdinalIgnoreCase))
        {
            if (headAttributes.Count == 0)
            {
                return null;
            }

            var removedNames = headAttributes.Values.OrderBy(name => name, StringComparer.OrdinalIgnoreCase);
            return $"attributes before deletion ({headAttributes.Count}): {FormatNameList(removedNames)}";
        }

        var addedAttributeNames = workingAttributes
            .Where(pair => !headAttributes.ContainsKey(pair.Key))
            .Select(pair => pair.Value)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(name => name, StringComparer.OrdinalIgnoreCase)
            .ToArray();

        if (addedAttributeNames.Length == 0)
        {
            return null;
        }

        return $"attributes added ({addedAttributeNames.Length}): {FormatNameList(addedAttributeNames)}";
    }

    private static Dictionary<string, string> CollectDomainAttributes(JsonElement entityObject)
    {
        var attributes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        if (!TryReadProperty(entityObject, "attributes", out var attributesElement) ||
            attributesElement.ValueKind != JsonValueKind.Array)
        {
            return attributes;
        }

        foreach (var attribute in attributesElement.EnumerateArray())
        {
            if (attribute.ValueKind != JsonValueKind.Object)
            {
                continue;
            }

            var modelType = TryReadStringProperty(attribute, "$Type");
            if (!string.Equals(modelType, DomainAttributeModelType, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            var key =
                TryReadStringProperty(attribute, "$ID") ??
                TryReadStringProperty(attribute, "$QualifiedName") ??
                Guid.NewGuid().ToString("N");

            var name =
                TryReadStringProperty(attribute, "name") ??
                TryReadStringProperty(attribute, "$QualifiedName") ??
                key;

            attributes[key] = name;
        }

        return attributes;
    }

    private static string FormatCounterList(Dictionary<string, int> counts, int maxEntries = 8)
    {
        var ordered = counts
            .OrderByDescending(pair => pair.Value)
            .ThenBy(pair => pair.Key, StringComparer.OrdinalIgnoreCase)
            .ToArray();

        var visible = ordered.Take(maxEntries).Select(pair => $"{pair.Key} x{pair.Value}").ToList();
        var remaining = ordered.Length - visible.Count;
        if (remaining > 0)
        {
            visible.Add($"+{remaining} more");
        }

        return string.Join(", ", visible);
    }

    private static string FormatNameList(IEnumerable<string> names, int maxEntries = 10)
    {
        var ordered = names
            .Where(name => !string.IsNullOrWhiteSpace(name))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(name => name, StringComparer.OrdinalIgnoreCase)
            .ToArray();

        if (ordered.Length == 0)
        {
            return "<none>";
        }

        var visible = ordered.Take(maxEntries).ToList();
        var remaining = ordered.Length - visible.Count;
        if (remaining > 0)
        {
            visible.Add($"+{remaining} more");
        }

        return string.Join(", ", visible);
    }

    private static string ShortTypeName(string modelType)
    {
        if (string.IsNullOrWhiteSpace(modelType))
        {
            return "<unknown>";
        }

        var separatorIndex = modelType.IndexOf('$');
        return separatorIndex >= 0 && separatorIndex < modelType.Length - 1
            ? modelType[(separatorIndex + 1)..]
            : modelType;
    }

    private static bool TryReadProperty(JsonElement element, string propertyName, out JsonElement value)
    {
        foreach (var property in element.EnumerateObject())
        {
            if (string.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
            {
                value = property.Value;
                return true;
            }
        }

        value = default;
        return false;
    }

    private static void IncrementCount(Dictionary<string, int> counts, string key)
    {
        if (counts.TryGetValue(key, out var existing))
        {
            counts[key] = existing + 1;
            return;
        }

        counts[key] = 1;
    }

    private static string? ResolveOwningResourceId(DumpSnapshot snapshot, string objectId)
    {
        if (string.IsNullOrWhiteSpace(objectId))
        {
            return null;
        }

        var visited = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var currentId = objectId;

        while (!string.IsNullOrWhiteSpace(currentId) && visited.Add(currentId))
        {
            if (snapshot.ResourcesById.ContainsKey(currentId))
            {
                return currentId;
            }

            if (!snapshot.ParentById.TryGetValue(currentId, out var parentId) ||
                string.IsNullOrWhiteSpace(parentId))
            {
                break;
            }

            currentId = parentId;
        }

        return null;
    }

    private static ResourceDescriptor? ResolveOwnerDescriptor(
        string resourceId,
        DumpSnapshot workingSnapshot,
        DumpSnapshot headSnapshot)
    {
        if (workingSnapshot.ResourcesById.TryGetValue(resourceId, out var working))
        {
            return working;
        }

        return headSnapshot.ResourcesById.TryGetValue(resourceId, out var head)
            ? head
            : null;
    }

    private static DumpSnapshot BuildSnapshot(JsonElement root)
    {
        var snapshot = new DumpSnapshot();
        var stack = new Stack<JsonElement>();
        stack.Push(root);

        while (stack.Count > 0)
        {
            var current = stack.Pop();
            switch (current.ValueKind)
            {
                case JsonValueKind.Object:
                {
                    var objectId = TryReadStringProperty(current, "$ID");
                    if (!string.IsNullOrWhiteSpace(objectId))
                    {
                        var clone = current.Clone();
                        snapshot.ObjectsById[objectId] = clone;

                        var containerId = TryReadStringProperty(current, "$ContainerID");
                        if (!string.IsNullOrWhiteSpace(containerId) &&
                            !string.Equals(containerId, objectId, StringComparison.OrdinalIgnoreCase))
                        {
                            snapshot.ParentById[objectId] = containerId;
                        }

                        var modelType = TryReadStringProperty(current, "$Type");
                        var containerProperty = TryReadStringProperty(current, "$ContainerProperty");
                        if (IsTrackableResource(modelType, containerProperty))
                        {
                            var descriptor = BuildResourceDescriptor(clone);
                            if (descriptor is not null)
                            {
                                snapshot.ResourcesById[objectId] = descriptor;
                            }
                        }
                    }

                    foreach (var property in current.EnumerateObject())
                    {
                        stack.Push(property.Value);
                    }

                    break;
                }

                case JsonValueKind.Array:
                    foreach (var item in current.EnumerateArray())
                    {
                        stack.Push(item);
                    }

                    break;
            }
        }

        return snapshot;
    }

    private static bool IsTrackableResource(string? modelType, string? containerProperty)
    {
        if (string.IsNullOrWhiteSpace(modelType))
        {
            return false;
        }

        if (!string.IsNullOrWhiteSpace(containerProperty) &&
            TrackableContainerProperties.Contains(containerProperty))
        {
            return true;
        }

        return TrackableDomainModelTypes.Contains(modelType);
    }

    private static ResourceDescriptor? BuildResourceDescriptor(JsonElement element)
    {
        var resourceId = TryReadStringProperty(element, "$ID");
        var modelType = TryReadStringProperty(element, "$Type");

        if (string.IsNullOrWhiteSpace(resourceId) || string.IsNullOrWhiteSpace(modelType))
        {
            return null;
        }

        var elementType = ResolveElementType(modelType);
        var elementName = ResolveElementName(element);
        if (string.Equals(elementName, "<unnamed>", StringComparison.Ordinal))
        {
            var shortId = resourceId.Length > 8 ? resourceId[..8] : resourceId;
            elementName = $"{elementType} [{shortId}]";
        }

        return new ResourceDescriptor(resourceId, modelType, elementType, elementName, element);
    }

    private static string ResolveElementType(string modelType)
    {
        if (ElementTypeOverrides.TryGetValue(modelType, out var overrideType))
        {
            return overrideType;
        }

        var separatorIndex = modelType.IndexOf('$');
        var typeName = separatorIndex >= 0 && separatorIndex < modelType.Length - 1
            ? modelType[(separatorIndex + 1)..]
            : modelType;

        if (typeName.EndsWith("Document", StringComparison.OrdinalIgnoreCase) &&
            typeName.Length > "Document".Length)
        {
            return typeName[..^"Document".Length];
        }

        return typeName;
    }

    private static string ResolveElementName(JsonElement element)
    {
        foreach (var propertyName in NameFields)
        {
            var value = TryReadStringProperty(element, propertyName);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return value;
            }
        }

        return "<unnamed>";
    }

    private static string? BuildModificationDetails(JsonElement previousValue, JsonElement currentValue)
    {
        if (previousValue.ValueKind != JsonValueKind.Object || currentValue.ValueKind != JsonValueKind.Object)
        {
            return null;
        }

        var previousProperties = previousValue.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
        var currentProperties = currentValue.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
        var detailParts = new List<string>();

        foreach (var (propertyName, currentPropertyValue) in currentProperties)
        {
            if (IgnoredDetailFields.Contains(propertyName))
            {
                continue;
            }

            if (!previousProperties.TryGetValue(propertyName, out var previousPropertyValue))
            {
                detailParts.Add($"{propertyName} added");
                continue;
            }

            if (!ElementsEqual(previousPropertyValue, currentPropertyValue))
            {
                detailParts.Add(DescribePropertyChange(propertyName, previousPropertyValue, currentPropertyValue));
            }
        }

        foreach (var propertyName in previousProperties.Keys)
        {
            if (IgnoredDetailFields.Contains(propertyName))
            {
                continue;
            }

            if (!currentProperties.ContainsKey(propertyName))
            {
                detailParts.Add($"{propertyName} removed");
            }
        }

        if (detailParts.Count == 0)
        {
            return null;
        }

        const int maxParts = 4;
        var visible = detailParts.Take(maxParts).ToList();
        var summary = string.Join("; ", visible);
        var remaining = detailParts.Count - visible.Count;

        if (remaining > 0)
        {
            summary = $"{summary}; +{remaining} more";
        }

        return summary;
    }

    private static string? MergeDetailTexts(string? primary, string? secondary)
    {
        var parts = new List<string>();
        if (!string.IsNullOrWhiteSpace(primary))
        {
            parts.Add(primary.Trim());
        }

        if (!string.IsNullOrWhiteSpace(secondary))
        {
            var trimmedSecondary = secondary.Trim();
            if (!parts.Contains(trimmedSecondary, StringComparer.Ordinal))
            {
                parts.Add(trimmedSecondary);
            }
        }

        return parts.Count == 0 ? null : string.Join("; ", parts);
    }

    private static string? TryReadStringProperty(JsonElement element, string propertyName)
    {
        foreach (var property in element.EnumerateObject())
        {
            if (!string.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            if (property.Value.ValueKind == JsonValueKind.String)
            {
                return property.Value.GetString();
            }

            if (property.Value.ValueKind == JsonValueKind.Number ||
                property.Value.ValueKind == JsonValueKind.True ||
                property.Value.ValueKind == JsonValueKind.False)
            {
                return property.Value.GetRawText();
            }
        }

        return null;
    }

    private static bool ElementsEqual(JsonElement left, JsonElement right)
    {
        if (left.ValueKind != right.ValueKind)
        {
            return false;
        }

        switch (left.ValueKind)
        {
            case JsonValueKind.Object:
            {
                var leftProperties = left.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
                var rightProperties = right.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);

                if (leftProperties.Count != rightProperties.Count)
                {
                    return false;
                }

                foreach (var (name, leftValue) in leftProperties)
                {
                    if (!rightProperties.TryGetValue(name, out var rightValue))
                    {
                        return false;
                    }

                    if (!ElementsEqual(leftValue, rightValue))
                    {
                        return false;
                    }
                }

                return true;
            }

            case JsonValueKind.Array:
            {
                var leftItems = left.EnumerateArray().ToArray();
                var rightItems = right.EnumerateArray().ToArray();
                if (leftItems.Length != rightItems.Length)
                {
                    return false;
                }

                for (var index = 0; index < leftItems.Length; index++)
                {
                    if (!ElementsEqual(leftItems[index], rightItems[index]))
                    {
                        return false;
                    }
                }

                return true;
            }

            case JsonValueKind.String:
                return string.Equals(left.GetString(), right.GetString(), StringComparison.Ordinal);

            case JsonValueKind.Number:
                return string.Equals(left.GetRawText(), right.GetRawText(), StringComparison.Ordinal);

            case JsonValueKind.True:
            case JsonValueKind.False:
                return left.GetBoolean() == right.GetBoolean();

            case JsonValueKind.Null:
            case JsonValueKind.Undefined:
                return true;

            default:
                return string.Equals(left.GetRawText(), right.GetRawText(), StringComparison.Ordinal);
        }
    }

    private static string DescribePropertyChange(string propertyName, JsonElement previous, JsonElement current)
    {
        if (previous.ValueKind == JsonValueKind.Array && current.ValueKind == JsonValueKind.Array)
        {
            var previousCount = previous.GetArrayLength();
            var currentCount = current.GetArrayLength();
            if (previousCount != currentCount)
            {
                return $"{propertyName} count {previousCount}->{currentCount}";
            }

            return $"{propertyName} entries updated";
        }

        if (IsScalar(previous.ValueKind) && IsScalar(current.ValueKind))
        {
            var previousText = FormatScalar(previous);
            var currentText = FormatScalar(current);
            if (!string.Equals(previousText, currentText, StringComparison.Ordinal))
            {
                return $"{propertyName} {previousText}->{currentText}";
            }
        }

        return $"{propertyName} updated";
    }

    private static bool IsScalar(JsonValueKind kind) =>
        kind is JsonValueKind.String or JsonValueKind.Number or JsonValueKind.True or JsonValueKind.False or JsonValueKind.Null;

    private static string FormatScalar(JsonElement value)
    {
        var text = value.ValueKind switch
        {
            JsonValueKind.String => value.GetString() ?? "null",
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Null => "null",
            _ => value.GetRawText(),
        };

        const int maxLength = 28;
        if (text.Length > maxLength)
        {
            text = $"{text[..maxLength]}...";
        }

        return text.Replace("\r", " ").Replace("\n", " ");
    }

    private static JsonDocument ParseDump(string path)
    {
        var text = File.ReadAllText(path);
        if (text.Length > 0 && text[0] == '\uFEFF')
        {
            text = text[1..];
        }

        return JsonDocument.Parse(text);
    }

    private sealed class DumpSnapshot
    {
        public Dictionary<string, JsonElement> ObjectsById { get; } = new(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, string> ParentById { get; } = new(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, ResourceDescriptor> ResourcesById { get; } = new(StringComparer.OrdinalIgnoreCase);
    }

    private sealed class MutableResourceChange
    {
        public MutableResourceChange(string changeType, ResourceDescriptor descriptor)
        {
            ChangeType = changeType;
            Descriptor = descriptor;
        }

        public string ChangeType { get; set; }

        public ResourceDescriptor Descriptor { get; set; }

        public string? DirectDetails { get; set; }

        public NestedChangeCounter NestedChanges { get; } = new();
    }

    private sealed class NestedChangeCounter
    {
        public int AddedCount { get; private set; }

        public int ModifiedCount { get; private set; }

        public int DeletedCount { get; private set; }

        public void Increment(string changeType)
        {
            switch (changeType)
            {
                case "Added":
                    AddedCount++;
                    break;
                case "Deleted":
                    DeletedCount++;
                    break;
                default:
                    ModifiedCount++;
                    break;
            }
        }

        public string? ToDetailText()
        {
            var total = AddedCount + ModifiedCount + DeletedCount;
            if (total <= 0)
            {
                return null;
            }

            var parts = new List<string>();
            if (AddedCount > 0)
            {
                parts.Add($"{AddedCount} added");
            }

            if (ModifiedCount > 0)
            {
                parts.Add($"{ModifiedCount} modified");
            }

            if (DeletedCount > 0)
            {
                parts.Add($"{DeletedCount} deleted");
            }

            return $"{total} nested change{(total == 1 ? string.Empty : "s")} ({string.Join(", ", parts)})";
        }
    }

    private sealed record MicroflowActionSummary(
        Dictionary<string, int> ActionCounts,
        Dictionary<string, HashSet<string>> ActionDescriptors);

    private sealed record ResourceDescriptor(
        string ResourceId,
        string ModelType,
        string ElementType,
        string ElementName,
        JsonElement Object);
}
