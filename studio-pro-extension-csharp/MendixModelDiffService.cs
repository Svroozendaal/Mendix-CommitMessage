using System.Text.Json;

namespace AutoCommitMessage;

/// <summary>
/// Computes resource-level Mendix model differences from two JSON dumps generated by <c>mx dump-mpr</c>.
/// </summary>
public static class MendixModelDiffService
{
    private static readonly string[] NameFields = { "$QualifiedName", "name", "$ID" };
    private static readonly HashSet<string> TrackableContainerProperties = new(StringComparer.OrdinalIgnoreCase)
    {
        "documents",
        "projectDocuments",
    };

    private static readonly HashSet<string> TrackableDomainModelTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "DomainModels$Entity",
        "DomainModels$Association",
        "DomainModels$Enumeration",
    };

    private static readonly Dictionary<string, string> ElementTypeOverrides = new(StringComparer.OrdinalIgnoreCase)
    {
        ["DomainModels$Entity"] = "Entity",
        ["DomainModels$Association"] = "Association",
        ["DomainModels$Enumeration"] = "Enumeration",
        ["Pages$Page"] = "Page",
        ["Pages$Snippet"] = "Snippet",
        ["Microflows$Microflow"] = "Microflow",
        ["Nanoflows$Nanoflow"] = "Nanoflow",
    };

    private static readonly HashSet<string> IgnoredDetailFields = new(StringComparer.Ordinal)
    {
        "$ID",
        "$Type",
        "$ContainerID",
        "$ContainerProperty",
        "$QualifiedName",
    };

    /// <summary>
    /// Compares two model dump JSON files and returns detected resource-level changes.
    /// </summary>
    /// <param name="workingJson">Path to the working-copy dump JSON.</param>
    /// <param name="headJson">Path to the HEAD dump JSON.</param>
    /// <returns>Collection of model changes.</returns>
    public static List<MendixModelChange> CompareDumps(string workingJson, string headJson)
    {
        using var workingDocument = ParseDump(workingJson);
        using var headDocument = ParseDump(headJson);

        var workingSnapshot = BuildSnapshot(workingDocument.RootElement);
        var headSnapshot = BuildSnapshot(headDocument.RootElement);
        var changeMap = new Dictionary<string, MutableResourceChange>(StringComparer.OrdinalIgnoreCase);

        foreach (var (resourceId, resource) in workingSnapshot.ResourcesById)
        {
            if (!headSnapshot.ResourcesById.ContainsKey(resourceId))
            {
                changeMap[resourceId] = new MutableResourceChange("Added", resource);
            }
        }

        foreach (var (resourceId, resource) in headSnapshot.ResourcesById)
        {
            if (!workingSnapshot.ResourcesById.ContainsKey(resourceId))
            {
                changeMap[resourceId] = new MutableResourceChange("Deleted", resource);
            }
        }

        foreach (var (resourceId, workingResource) in workingSnapshot.ResourcesById)
        {
            if (!headSnapshot.ResourcesById.TryGetValue(resourceId, out var headResource))
            {
                continue;
            }

            if (ElementsEqual(workingResource.Object, headResource.Object))
            {
                continue;
            }

            var modified = EnsureModifiedChange(changeMap, resourceId, workingResource);
            modified.DirectDetails = MergeDetailTexts(
                modified.DirectDetails,
                BuildModificationDetails(headResource.Object, workingResource.Object));
        }

        AddNestedOwnershipChanges(
            changeMap,
            workingSnapshot,
            headSnapshot,
            workingSnapshot.ObjectsById.Keys.Except(headSnapshot.ObjectsById.Keys, StringComparer.OrdinalIgnoreCase),
            "Added",
            useWorkingSnapshot: true);

        AddNestedOwnershipChanges(
            changeMap,
            workingSnapshot,
            headSnapshot,
            headSnapshot.ObjectsById.Keys.Except(workingSnapshot.ObjectsById.Keys, StringComparer.OrdinalIgnoreCase),
            "Deleted",
            useWorkingSnapshot: false);

        var modifiedObjectIds = workingSnapshot.ObjectsById.Keys
            .Intersect(headSnapshot.ObjectsById.Keys, StringComparer.OrdinalIgnoreCase)
            .Where(objectId => !ElementsEqual(workingSnapshot.ObjectsById[objectId], headSnapshot.ObjectsById[objectId]));

        AddNestedOwnershipChanges(
            changeMap,
            workingSnapshot,
            headSnapshot,
            modifiedObjectIds,
            "Modified",
            useWorkingSnapshot: true);

        return changeMap.Values
            .Select(ToModelChange)
            .OrderBy(change => change.ElementType, StringComparer.OrdinalIgnoreCase)
            .ThenBy(change => change.ElementName, StringComparer.OrdinalIgnoreCase)
            .ThenBy(change => change.ChangeType, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private static void AddNestedOwnershipChanges(
        Dictionary<string, MutableResourceChange> changeMap,
        DumpSnapshot workingSnapshot,
        DumpSnapshot headSnapshot,
        IEnumerable<string> changedObjectIds,
        string nestedChangeType,
        bool useWorkingSnapshot)
    {
        var ownerSnapshot = useWorkingSnapshot ? workingSnapshot : headSnapshot;

        foreach (var objectId in changedObjectIds)
        {
            if (ownerSnapshot.ResourcesById.ContainsKey(objectId))
            {
                continue;
            }

            var ownerResourceId = ResolveOwningResourceId(ownerSnapshot, objectId);
            if (string.IsNullOrWhiteSpace(ownerResourceId))
            {
                continue;
            }

            var ownerDescriptor = ResolveOwnerDescriptor(ownerResourceId, workingSnapshot, headSnapshot);
            if (ownerDescriptor is null)
            {
                continue;
            }

            if (changeMap.TryGetValue(ownerResourceId, out var existingHardChange) &&
                existingHardChange.ChangeType is "Added" or "Deleted")
            {
                continue;
            }

            var modified = EnsureModifiedChange(changeMap, ownerResourceId, ownerDescriptor);
            modified.NestedChanges.Increment(nestedChangeType);
        }
    }

    private static MutableResourceChange EnsureModifiedChange(
        Dictionary<string, MutableResourceChange> changeMap,
        string resourceId,
        ResourceDescriptor descriptor)
    {
        if (changeMap.TryGetValue(resourceId, out var existing))
        {
            if (existing.ChangeType is "Added" or "Deleted")
            {
                return existing;
            }

            existing.ChangeType = "Modified";
            existing.Descriptor = descriptor;
            return existing;
        }

        var created = new MutableResourceChange("Modified", descriptor);
        changeMap[resourceId] = created;
        return created;
    }

    private static MendixModelChange ToModelChange(MutableResourceChange change)
    {
        var details = MergeDetailTexts(change.DirectDetails, change.NestedChanges.ToDetailText());
        return new MendixModelChange(
            change.ChangeType,
            change.Descriptor.ElementType,
            change.Descriptor.ElementName,
            details);
    }

    private static string? ResolveOwningResourceId(DumpSnapshot snapshot, string objectId)
    {
        if (string.IsNullOrWhiteSpace(objectId))
        {
            return null;
        }

        var visited = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var currentId = objectId;

        while (!string.IsNullOrWhiteSpace(currentId) && visited.Add(currentId))
        {
            if (snapshot.ResourcesById.ContainsKey(currentId))
            {
                return currentId;
            }

            if (!snapshot.ParentById.TryGetValue(currentId, out var parentId) ||
                string.IsNullOrWhiteSpace(parentId))
            {
                break;
            }

            currentId = parentId;
        }

        return null;
    }

    private static ResourceDescriptor? ResolveOwnerDescriptor(
        string resourceId,
        DumpSnapshot workingSnapshot,
        DumpSnapshot headSnapshot)
    {
        if (workingSnapshot.ResourcesById.TryGetValue(resourceId, out var working))
        {
            return working;
        }

        return headSnapshot.ResourcesById.TryGetValue(resourceId, out var head)
            ? head
            : null;
    }

    private static DumpSnapshot BuildSnapshot(JsonElement root)
    {
        var snapshot = new DumpSnapshot();
        var stack = new Stack<JsonElement>();
        stack.Push(root);

        while (stack.Count > 0)
        {
            var current = stack.Pop();
            switch (current.ValueKind)
            {
                case JsonValueKind.Object:
                {
                    var objectId = TryReadStringProperty(current, "$ID");
                    if (!string.IsNullOrWhiteSpace(objectId))
                    {
                        var clone = current.Clone();
                        snapshot.ObjectsById[objectId] = clone;

                        var containerId = TryReadStringProperty(current, "$ContainerID");
                        if (!string.IsNullOrWhiteSpace(containerId) &&
                            !string.Equals(containerId, objectId, StringComparison.OrdinalIgnoreCase))
                        {
                            snapshot.ParentById[objectId] = containerId;
                        }

                        var modelType = TryReadStringProperty(current, "$Type");
                        var containerProperty = TryReadStringProperty(current, "$ContainerProperty");
                        if (IsTrackableResource(modelType, containerProperty))
                        {
                            var descriptor = BuildResourceDescriptor(clone);
                            if (descriptor is not null)
                            {
                                snapshot.ResourcesById[objectId] = descriptor;
                            }
                        }
                    }

                    foreach (var property in current.EnumerateObject())
                    {
                        stack.Push(property.Value);
                    }

                    break;
                }

                case JsonValueKind.Array:
                    foreach (var item in current.EnumerateArray())
                    {
                        stack.Push(item);
                    }

                    break;
            }
        }

        return snapshot;
    }

    private static bool IsTrackableResource(string? modelType, string? containerProperty)
    {
        if (string.IsNullOrWhiteSpace(modelType))
        {
            return false;
        }

        if (!string.IsNullOrWhiteSpace(containerProperty) &&
            TrackableContainerProperties.Contains(containerProperty))
        {
            return true;
        }

        return TrackableDomainModelTypes.Contains(modelType);
    }

    private static ResourceDescriptor? BuildResourceDescriptor(JsonElement element)
    {
        var resourceId = TryReadStringProperty(element, "$ID");
        var modelType = TryReadStringProperty(element, "$Type");

        if (string.IsNullOrWhiteSpace(resourceId) || string.IsNullOrWhiteSpace(modelType))
        {
            return null;
        }

        var elementType = ResolveElementType(modelType);
        var elementName = ResolveElementName(element);
        if (string.Equals(elementName, "<unnamed>", StringComparison.Ordinal))
        {
            var shortId = resourceId.Length > 8 ? resourceId[..8] : resourceId;
            elementName = $"{elementType} [{shortId}]";
        }

        return new ResourceDescriptor(resourceId, modelType, elementType, elementName, element);
    }

    private static string ResolveElementType(string modelType)
    {
        if (ElementTypeOverrides.TryGetValue(modelType, out var overrideType))
        {
            return overrideType;
        }

        var separatorIndex = modelType.IndexOf('$');
        var typeName = separatorIndex >= 0 && separatorIndex < modelType.Length - 1
            ? modelType[(separatorIndex + 1)..]
            : modelType;

        if (typeName.EndsWith("Document", StringComparison.OrdinalIgnoreCase) &&
            typeName.Length > "Document".Length)
        {
            return typeName[..^"Document".Length];
        }

        return typeName;
    }

    private static string ResolveElementName(JsonElement element)
    {
        foreach (var propertyName in NameFields)
        {
            var value = TryReadStringProperty(element, propertyName);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return value;
            }
        }

        return "<unnamed>";
    }

    private static string? BuildModificationDetails(JsonElement previousValue, JsonElement currentValue)
    {
        if (previousValue.ValueKind != JsonValueKind.Object || currentValue.ValueKind != JsonValueKind.Object)
        {
            return null;
        }

        var previousProperties = previousValue.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
        var currentProperties = currentValue.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
        var detailParts = new List<string>();

        foreach (var (propertyName, currentPropertyValue) in currentProperties)
        {
            if (IgnoredDetailFields.Contains(propertyName))
            {
                continue;
            }

            if (!previousProperties.TryGetValue(propertyName, out var previousPropertyValue))
            {
                detailParts.Add($"{propertyName} added");
                continue;
            }

            if (!ElementsEqual(previousPropertyValue, currentPropertyValue))
            {
                detailParts.Add(DescribePropertyChange(propertyName, previousPropertyValue, currentPropertyValue));
            }
        }

        foreach (var propertyName in previousProperties.Keys)
        {
            if (IgnoredDetailFields.Contains(propertyName))
            {
                continue;
            }

            if (!currentProperties.ContainsKey(propertyName))
            {
                detailParts.Add($"{propertyName} removed");
            }
        }

        if (detailParts.Count == 0)
        {
            return null;
        }

        const int maxParts = 4;
        var visible = detailParts.Take(maxParts).ToList();
        var summary = string.Join("; ", visible);
        var remaining = detailParts.Count - visible.Count;

        if (remaining > 0)
        {
            summary = $"{summary}; +{remaining} more";
        }

        return summary;
    }

    private static string? MergeDetailTexts(string? primary, string? secondary)
    {
        var parts = new List<string>();
        if (!string.IsNullOrWhiteSpace(primary))
        {
            parts.Add(primary.Trim());
        }

        if (!string.IsNullOrWhiteSpace(secondary))
        {
            var trimmedSecondary = secondary.Trim();
            if (!parts.Contains(trimmedSecondary, StringComparer.Ordinal))
            {
                parts.Add(trimmedSecondary);
            }
        }

        return parts.Count == 0 ? null : string.Join("; ", parts);
    }

    private static string? TryReadStringProperty(JsonElement element, string propertyName)
    {
        foreach (var property in element.EnumerateObject())
        {
            if (!string.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            if (property.Value.ValueKind == JsonValueKind.String)
            {
                return property.Value.GetString();
            }

            if (property.Value.ValueKind == JsonValueKind.Number ||
                property.Value.ValueKind == JsonValueKind.True ||
                property.Value.ValueKind == JsonValueKind.False)
            {
                return property.Value.GetRawText();
            }
        }

        return null;
    }

    private static bool ElementsEqual(JsonElement left, JsonElement right)
    {
        if (left.ValueKind != right.ValueKind)
        {
            return false;
        }

        switch (left.ValueKind)
        {
            case JsonValueKind.Object:
            {
                var leftProperties = left.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
                var rightProperties = right.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);

                if (leftProperties.Count != rightProperties.Count)
                {
                    return false;
                }

                foreach (var (name, leftValue) in leftProperties)
                {
                    if (!rightProperties.TryGetValue(name, out var rightValue))
                    {
                        return false;
                    }

                    if (!ElementsEqual(leftValue, rightValue))
                    {
                        return false;
                    }
                }

                return true;
            }

            case JsonValueKind.Array:
            {
                var leftItems = left.EnumerateArray().ToArray();
                var rightItems = right.EnumerateArray().ToArray();
                if (leftItems.Length != rightItems.Length)
                {
                    return false;
                }

                for (var index = 0; index < leftItems.Length; index++)
                {
                    if (!ElementsEqual(leftItems[index], rightItems[index]))
                    {
                        return false;
                    }
                }

                return true;
            }

            case JsonValueKind.String:
                return string.Equals(left.GetString(), right.GetString(), StringComparison.Ordinal);

            case JsonValueKind.Number:
                return string.Equals(left.GetRawText(), right.GetRawText(), StringComparison.Ordinal);

            case JsonValueKind.True:
            case JsonValueKind.False:
                return left.GetBoolean() == right.GetBoolean();

            case JsonValueKind.Null:
            case JsonValueKind.Undefined:
                return true;

            default:
                return string.Equals(left.GetRawText(), right.GetRawText(), StringComparison.Ordinal);
        }
    }

    private static string DescribePropertyChange(string propertyName, JsonElement previous, JsonElement current)
    {
        if (previous.ValueKind == JsonValueKind.Array && current.ValueKind == JsonValueKind.Array)
        {
            var previousCount = previous.GetArrayLength();
            var currentCount = current.GetArrayLength();
            if (previousCount != currentCount)
            {
                return $"{propertyName} count {previousCount}->{currentCount}";
            }

            return $"{propertyName} entries updated";
        }

        if (IsScalar(previous.ValueKind) && IsScalar(current.ValueKind))
        {
            var previousText = FormatScalar(previous);
            var currentText = FormatScalar(current);
            if (!string.Equals(previousText, currentText, StringComparison.Ordinal))
            {
                return $"{propertyName} {previousText}->{currentText}";
            }
        }

        return $"{propertyName} updated";
    }

    private static bool IsScalar(JsonValueKind kind) =>
        kind is JsonValueKind.String or JsonValueKind.Number or JsonValueKind.True or JsonValueKind.False or JsonValueKind.Null;

    private static string FormatScalar(JsonElement value)
    {
        var text = value.ValueKind switch
        {
            JsonValueKind.String => value.GetString() ?? "null",
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Null => "null",
            _ => value.GetRawText(),
        };

        const int maxLength = 28;
        if (text.Length > maxLength)
        {
            text = $"{text[..maxLength]}...";
        }

        return text.Replace("\r", " ").Replace("\n", " ");
    }

    private static JsonDocument ParseDump(string path)
    {
        var text = File.ReadAllText(path);
        if (text.Length > 0 && text[0] == '\uFEFF')
        {
            text = text[1..];
        }

        return JsonDocument.Parse(text);
    }

    private sealed class DumpSnapshot
    {
        public Dictionary<string, JsonElement> ObjectsById { get; } = new(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, string> ParentById { get; } = new(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, ResourceDescriptor> ResourcesById { get; } = new(StringComparer.OrdinalIgnoreCase);
    }

    private sealed class MutableResourceChange
    {
        public MutableResourceChange(string changeType, ResourceDescriptor descriptor)
        {
            ChangeType = changeType;
            Descriptor = descriptor;
        }

        public string ChangeType { get; set; }

        public ResourceDescriptor Descriptor { get; set; }

        public string? DirectDetails { get; set; }

        public NestedChangeCounter NestedChanges { get; } = new();
    }

    private sealed class NestedChangeCounter
    {
        public int AddedCount { get; private set; }

        public int ModifiedCount { get; private set; }

        public int DeletedCount { get; private set; }

        public void Increment(string changeType)
        {
            switch (changeType)
            {
                case "Added":
                    AddedCount++;
                    break;
                case "Deleted":
                    DeletedCount++;
                    break;
                default:
                    ModifiedCount++;
                    break;
            }
        }

        public string? ToDetailText()
        {
            var total = AddedCount + ModifiedCount + DeletedCount;
            if (total <= 0)
            {
                return null;
            }

            var parts = new List<string>();
            if (AddedCount > 0)
            {
                parts.Add($"{AddedCount} added");
            }

            if (ModifiedCount > 0)
            {
                parts.Add($"{ModifiedCount} modified");
            }

            if (DeletedCount > 0)
            {
                parts.Add($"{DeletedCount} deleted");
            }

            return $"{total} nested change{(total == 1 ? string.Empty : "s")} ({string.Join(", ", parts)})";
        }
    }

    private sealed record ResourceDescriptor(
        string ResourceId,
        string ModelType,
        string ElementType,
        string ElementName,
        JsonElement Object);
}
